#!/bin/sh

# Copyright (c) 2014 Vincent Bernat <bernat@luffy.cx>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

set -e

ESC="$(printf '\033')"
if [ -t 1 ] && [ -z "$noterm" ]; then
    NORMAL="${ESC}[0m"
    RED="${ESC}[31;1m"
    GREEN="${ESC}[32;1m"
    YELLOW="${ESC}[33;1m"
    BLUE="${ESC}[34;1m"
    BEGINNING="$(printf '\015\033')[K"
else
    BEGINNING="\n"
fi

log_begin_msg () {
    [ -n "$SILENT" ] || {
        printf "${BEGINNING}"
        printf "${BLUE}[…]${NORMAL} $1${BLUE}...${NORMAL} "
    }
}
log_ok_msg () {
    [ -n "$SILENT" ] || {
        printf "${BEGINNING}"
        echo "$GREEN[✔]$NORMAL $1."
    }
}
log_warn_msg () {
    [ -n "$SILENT" ] || {
        printf "${BEGINNING}"
        echo "$YELLOW[⚡]$NORMAL $1!"
    }
}
log_error_msg () {
    printf "${BEGINNING}"
    echo "$RED[✘]$NORMAL $1!"
    exit 1
}
log_info_msg () {
    [ -n "$SILENT" ] || {
        printf "${BEGINNING}"
        echo "$BLUE[∗]$NORMAL $1."
    }
}

usage() {
    >&2 cat <<EOF
Usage: $PROGNAME [ options ]
Boot any Linux kernel using host root filesystem as a base.

Options:

 -s, --silent          Makes $PROGNAME silent.
 -k, --kernel=BZIMAGE  Specify the kernel to boot. By default, boot on the
                       running kernel.
 -r, --root=DIR        Specify the directory to use as the root file system.
 -w, --readwrite       Enable read/write access on the provided root file system.
 -c, --cmdline=ARGS    Additional parameters for the kernel.
 -e, --exec=CMD        Execute a command instead of spawning a shell.
 -1, --pid1            Execute the shell or the command as PID 1.
 --qemu=OPTIONS        Additional options for QEMU.
 --net                 Enable network access through the host.
 --force               Allow running dangerous configuration.

EOF
}

check_kernel_version() {
    log_begin_msg "Checking kernel version"
    [ -f "$KERNEL" ] || log_error_msg "Unable to find kernel $KERNEL"
    [ -r "$KERNEL" ] || log_error_msg "Kernel $KERNEL is not readable.\n    Try \`setfacl -m u:$USER:r $KERNEL'"

    # A recent version of `file` is able to extract the
    # information. Since it is not widely available, let use some hack
    # method.
    VERSION=$(cat <<EOF |
cat
gunzip  \\\037\\\213\\\010 xy
unxz    \\\3757zXZ\\\000   abcde
bunzip2 BZh                xy
unlzma  \\\135\\\0\\\0\\\0 xxx
EOF
              while read cmd sig1 sig2; do
                  case $sig1,$sig2 in
                      ,) poss="0:_" ;;
                      *) poss=$(tr "${sig1}\n${sig2}" "\n${sig2}=" < "$KERNEL" | grep -abo "^${sig2}" || true) ;;
                  esac
                  [ -n "$poss" ] || continue
                  for pos in $poss; do
                      pos=${pos%%:*}
                      tail -c+$pos "$KERNEL" | $cmd 2> /dev/null | strings -20 | \
                          grep ^Linux.version | head -1
                  done
              done | head -1)

    [ -n "$VERSION" ] || log_error_msg "Unable to determine version for $KERNEL"
    VERSION="${VERSION#Linux version }"
    VERSION="${VERSION%% *}"
    log_ok_msg "Found kernel $VERSION"
}


check_kernel_configuration() {
    log_begin_msg "Check kernel configuration"
    CONFIG="$(dirname $KERNEL)/config-$VERSION"
    [ -f "$CONFIG" ] || log_error_msg "Unable to find configuration file $CONFIG"
    cat <<EOF | while read el; do
9P_FS=[ym]
NET_9P=[ym]
NET_9P_VIRTIO=[ym]
VIRTIO=[ym]
VIRTIO_PCI=[ym]
SERIAL_8250=y
SERIAL_8250_CONSOLE=y
TMPFS=y
SYSFS=y
PROC_FS=y
BLK_DEV_INITRD=y
RD_GZIP=y
DEVTMPFS=[ym]
EOF
        grep -qx "CONFIG_$el" $CONFIG || log_error_msg "Kernel not configured with CONFIG_$el"
    done
    [ -n "$RW" ] || {
        if grep -Eqc "CONFIG_OVERLAY(FS|)_FS=[ym]" $CONFIG; then
            log_ok_msg "Kernel configuration checked. overlayfs present"
            UNION="${UNION}${UNION+ }overlayfs"
        fi
        if grep -qc "CONFIG_AUFS_FS=[ym]" $CONFIG; then
            log_ok_msg "Kernel configuration checked. AUFS present"
            UNION="${UNION}${UNION+ }aufs"
        fi
        [ -n "$UNION" ] || \
            log_warn_msg "Kernel configuration checked. Neither overlayfs nor AUFS present"
    }

    log_begin_msg "Search for modules"
    for dir in "$(dirname $KERNEL)/lib/modules/$VERSION" "/lib/modules/$VERSION"; do
        [ -d $dir ] || continue
        MODULES="$dir"
        break
    done
    if [ -z "$MODULES" ]; then
        log_warn_msg "Unable to find module directory"
    else
        log_ok_msg "Modules are in $MODULES"
    fi
}

check_kernel() {
    check_kernel_version
    check_kernel_configuration
}

check_dependencies() {
    log_begin_msg "Checking if dependencies are present"
    which busybox 2> /dev/null > /dev/null || log_error_msg "Busybox is not installed"
    which qemu-system-x86_64 2> /dev/null > /dev/null || log_error_msg "qemu-system is not installed"
    log_ok_msg "All dependencies are met"
}

setup_tmp () {
    TMP=$(mktemp -d)
    trap "rm -rf $TMP" EXIT
    log_info_msg "TMP is $TMP"
}

setup_initrd () {
    log_begin_msg "Build initrd"
    DESTDIR=$TMP/initrd
    mkdir -p $DESTDIR

    # Copy busybox and eventually insmod
    bins="busybox"
    busybox --list | grep -qFx insmod || bins="$bins insmod"
    for bin in $bins; do
        install -D "$(which $bin)" ${DESTDIR}/bin/$bin
        for x in $(ldd "$(which $bin)" 2> /dev/null | sed -e '
               /\//!d;
               /linux-gate/d;
               /=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
               s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/' 2>/dev/null); do
            [ -f "${DESTDIR}/$x" ] || install -D "$x" "${DESTDIR}/$x"
        done
    done

    # Configure busybox
    for applet in $(${DESTDIR}/bin/busybox --list); do
        ln -s busybox ${DESTDIR}/bin/${applet}
    done

    # Add modules
    [ -z "$MODULES" ] || {
        modules="9pnet_virtio 9p virtio_pci"
        [ -z "$UNION" ] || modules="$modules $UNION"
        for mod in $modules; do
            modprobe --all --set-version="${VERSION}" -d ${MODULES}/../../.. \
                --ignore-install --quiet --show-depends $mod > /dev/null || {
                log_warn_msg "Unable to find module $mod"
                log_begin_msg "Continue building initrd"
            }
            modprobe --all --set-version="${VERSION}" -d ${MODULES}/../../.. \
                --ignore-install --quiet --show-depends $mod |
            while read prefix kmod options ; do
                [ "${prefix}" = "insmod" ] || continue
                grep -qFw "$kmod" ${DESTDIR}/modules 2> /dev/null || {
                    install -D "$kmod" "${DESTDIR}/${kmod}"
                    echo $prefix $kmod $options >> ${DESTDIR}/modules
                }
            done
        done
    }

    # Copy this program
    cp "$PROGNAME" ${DESTDIR}/init

    # Create /tmp
    mkdir ${DESTDIR}/tmp

    # Build initrd
    (cd "${DESTDIR}" && find . | cpio --quiet -R 0:0 -o -H newc) | gzip > $TMP/initrd.gz

    log_ok_msg "initrd built in $TMP/initrd.gz"
}

start_vm () {
    name=$(echo eudyptula-${VERSION} | tr '.' '-')
    log_info_msg "Start VM $name"

    # Configuration settings
    mkdir "$TMP/config"
    case $PWD in
        $HOME*) echo /root"${PWD#$HOME}" > "$TMP/config/pwd" ;;
        *) echo "$PWD" > "$TMP/config/pwd" ;;
    esac
    echo "$TERM"  > "$TMP/config/term"
    echo "$SHELL" > "$TMP/config/shell"
    echo "$name"  > "$TMP/config/uts"
    [ -z "$PID1" ] || touch "$TMP/config/pid1"
    [ -z "$RW" ]   || touch "$TMP/config/rw"
    [ -z "$UNION" ] || echo "$UNION" > "$TMP/config/union"
    [ $# -eq 0 ] || echo "exec" "$@" > "$TMP/config/exec"

    append="console=ttyS0 panic=1 quiet $CMDLINE"
    [ -t 1 ] || append="$append noterm=1"
    [ -z "$SILENT" ] || append="$append SILENT=1"
    qemu="$QEMU"
    [ x"$NET" != x"1" ] || {
        mac=50:54:00:00:00:42
        qemu="$qemu -net nic,model=virtio,macaddr=$mac,vlan=1"
        qemu="$qemu -net user,vlan=1,name=internet"
    }
    # /root is mounted with version 9p2000.u to allow access to /dev,
    # /sys and to mount new partitions over them. This is not the case
    # for 9p2000.L.
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
        exec qemu-system-x86_64 \
        -enable-kvm \
        -nodefconfig -nodefaults \
        -display none \
        \
        -chardev stdio,id=charserial0,signal=off \
        -device isa-serial,chardev=charserial0,id=serial0 \
        -chardev socket,id=charserial1,path=$TMP/vm-$name-serial.pipe,server,nowait \
        -device isa-serial,chardev=charserial1,id=serial1 \
        \
        -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server,nowait \
        -mon chardev=con0,mode=readline,default \
        \
        -fsdev local,security_model=passthrough,id=fsdev-root,path=${ROOT} \
        -device virtio-9p-pci,id=fs-root,fsdev=fsdev-root,mount_tag=rootshare \
        -fsdev local,security_model=none,id=fsdev-home,path=${HOME} \
        -device virtio-9p-pci,id=fs-home,fsdev=fsdev-home,mount_tag=homeshare \
        -fsdev local,security_model=none,id=fsdev-modules,path=${MODULES}/..,readonly \
        -device virtio-9p-pci,id=fs-modules,fsdev=fsdev-modules,mount_tag=moduleshare \
        -fsdev local,security_model=passthrough,id=fsdev-config,path=$TMP/config \
        -device virtio-9p-pci,id=fs-config,fsdev=fsdev-config,mount_tag=configshare \
        \
        -gdb unix:$TMP/vm-$name-gdb.pipe,server,nowait \
        -no-reboot \
        -kernel $KERNEL \
        -initrd $TMP/initrd.gz \
        -append "$append" \
        \
        $qemu
EOF
    log_info_msg "GDB server listening on $TMP/vm-$name-gdb.pipe"
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    log_info_msg "ttyS1 listening on      $TMP/vm-$name-serial.pipe"
    chmod +x "$TMP/vm-$name.exec"
    "$TMP/vm-$name.exec"
    log_info_msg "VM terminated"
}

# FSM
export STATE=${STATE:-BEGIN}
case $$,$STATE in
    1,BEGIN)
        # In initrd
        log_info_msg "initrd started"
        export PATH=/usr/local/bin:/usr/bin:/bin:/sbin:/usr/local/sbin:/usr/sbin
        export HOME=/root

        [ ! -f /modules ] || {
            log_info_msg "Loading modules"
            . /modules
        }

        log_begin_msg "Load configuration"
        mount -n -t tmpfs tmpfs /tmp -o rw
        mkdir /tmp/config
        mount -t 9p configshare /tmp/config -o trans=virtio,version=9p2000.u,access=0,rw || \
            log_error_msg "Unable to load configuration"

        # Various config stuff
        hostname "$(cat /tmp/config/uts)"
        [ ! -f /tmp/config/pid1 ] || export PID1=1
        [ ! -f /tmp/config/rw ]   || export RW=1
        [ ! -f /tmp/config/union ] || export UNION="$(cat /tmp/config/union)"
        export TERM=$(cat /tmp/config/term)
        export SHELL=$(cat /tmp/config/shell)
        log_ok_msg "Configuration loaded"

        log_begin_msg "Setup root file system"
        mkdir /tmp/target
        mkdir /tmp/target/ro
        mkdir /tmp/target/overlay
        if [ -z "$RW" ]; then
            mkdir /tmp/target/rw
            mount -n -t 9p rootshare /tmp/target/ro -o trans=virtio,version=9p2000.u,ro
            mount -n -t tmpfs tmpfs  /tmp/target/rw -o rw
            set -- $UNION
            while [ $# -gt 0 ]; do
                case $1 in
                    aufs)
                        ! mount -n -t aufs aufs /tmp/target/overlay \
                          -o noxino,noatime,dirs=/tmp/target/rw:/tmp/target/ro=ro 2> /dev/null || break
                        log_warn_msg "Unable to use AUFS"
                        ;;
                    overlayfs)
                        ! mount -n -t overlayfs overlayfs /tmp/target/overlay \
                          -o lowerdir=/tmp/target/ro,upperdir=/tmp/target/rw,noatime 2> /dev/null || break
                        log_warn_msg "Unable to use overlayfs"
                        ;;
                esac
                shift
            done
            [ $# -gt 0 ] || \
                mount -n --bind /tmp/target/ro /tmp/target/overlay
            log_ok_msg "Root file system setup"

            log_begin_msg "Clean /tmp and /run"
            for fs in /run /var/run /var/tmp /var/log /tmp; do
                if [ -d /tmp/target/overlay$fs ] && [ ! -h /tmp/target/overlay$fs ]; then
                    mount -t tmpfs tmpfs /tmp/target/overlay$fs -o rw,nosuid,nodev
                fi
            done
            log_ok_msg "/tmp, /run and others are clean"
        else
            mount -n -t 9p    rootshare /tmp/target/overlay -o trans=virtio,version=9p2000.u,rw
        fi

        log_begin_msg "Setup /proc and /sys"
        mount -n -t proc  proc /tmp/target/overlay/proc
        mount -n -t sysfs sys  /tmp/target/overlay/sys
        log_ok_msg "/proc and /sys setup"

        log_begin_msg "Mount /root"
        mount -t 9p homeshare /tmp/target/overlay/root -o trans=virtio,version=9p2000.L,access=0,rw || \
            log_error_msg "Unable to mount /root"
        log_ok_msg "/root mounted"
        log_begin_msg "Mount /lib/modules"
        mount -t 9p moduleshare /tmp/target/overlay/lib/modules -o trans=virtio,version=9p2000.L,access=0,ro || \
            log_error_msg "Unable to mount /lib/modules"
        log_ok_msg "/root and /lib/modules mounted"

        mkdir /tmp/target/overlay/tmp/config
        mount --bind /tmp/config /tmp/target/overlay/tmp/config

        log_info_msg "Change root"
        export STATE=CHROOTED
        cp /init /tmp/target/overlay/tmp
        exec chroot /tmp/target/overlay /tmp/init
        ;;

    1,CHROOTED)
        log_begin_msg "Starting udev"
        udev_log=err
        mount -n -o size=10M,mode=0755 -t devtmpfs devtmpfs /dev
        udevadm info --cleanup-db
        udevd --daemon
        udevadm trigger --action=add
        udevadm settle
        mkdir -p /dev/pts
        mount -t devpts devpts /dev/pts 2> /dev/null || true
        log_ok_msg "udev started"

        sysctl -q -w kernel.panic_on_oops=1

        log_begin_msg "Configure network"
        ip link set up dev lo
        for iface in /sys/class/net/*; do
            if [ x"$(cat "$iface/address")" = x"50:54:00:00:00:42" ]; then
                # We don't use DHCP as the root filesystem may be read-only
                ip link set up dev "${iface##*/}"
                ip addr add 10.0.2.14/24 dev "${iface##*/}"
                ip route add default via 10.0.2.2
                echo "nameserver 10.0.2.3" > /tmp/resolv.conf
                mount --bind /tmp/resolv.conf /etc/resolv.conf
                break
            fi
            iface=
        done
        log_ok_msg "Network configured${iface:+ (${iface##*/})}"

        # Switch to the appropriate directory we were in
        cd $HOME
        cd $(cat /tmp/config/pwd) 2> /dev/null || true

        # Do we have an exec share?
        if [ -f /tmp/config/exec ]; then
            ret=0
            ${PID1:+exec} sh /tmp/config/exec || ret=$?
            echo $ret > /tmp/config/ret
            echo b > /proc/sysrq-trigger
        fi

        log_info_msg "Setup terminal"
        export STATE=GETTY
        exec setsid /sbin/getty -L ttyS0 -a root -l /tmp/init -i 115200 $TERM
        ;;

    1,GETTY)
        log_begin_msg "Setup terminal size"
        stty -echo
        stty raw
        printf '\033[18t'
        width=
        height=
        p=0
        while true; do
            char="$(timeout --foreground 1s dd bs=1 count=1 2> /dev/null || true)"
            case "$p,$char" in
                "0,;")
                    # End of CSI
                    p=1
                    ;;
                "1,;")
                    # End of height
                    stty rows $height
                    p=2
                    ;;
                "1,"*)
                    height="$height$char"
                    ;;
                "2,t"|"2,")
                    # End of width
                    stty columns $width
                    p=3
                    ;;
                "2,"*)
                    width="$width$char"
                    ;;
            esac
            [ x"$char" != x ] || break
            [ x"$p" != x"3" ] || break
        done
        stty -raw
        stty echo
        log_ok_msg "Terminal size is $(tput cols)x$(tput lines)"

        log_info_msg "Spawning a shell"
        export SSH_TTY=$(tty)
        for SHELL in $SHELL /bin/bash /bin/sh; do
            [ ! -x $SHELL ] || break
        done
        ret=0
        ${PID1:+exec} ${SHELL} -i || ret=$?
        echo $ret > /tmp/config/ret
        echo b > /proc/sysrq-trigger
        ;;

    *,BEGIN)
        # Initial state
        PROGNAME="$(readlink -f "$0")"
        ARGS="$(getopt -n eudyptula-boot \
            -o +hsk:r:c:1w \
            --longoptions help,silent,kernel:,root:,cmdline:,qemu:,net,pid1,readwrite,force \
            -- "$@")" || \
            log_error_msg "Invalid option, use --help for more information"
        eval set -- "$ARGS"
        while true; do
            case "$1" in
                -h | --help)
                    usage
                    exit 0
                    ;;
                -s | --silent)
                    SILENT=1
                    shift
                    ;;
                -k | --kernel)
                    KERNEL="$(readlink -f "$2")"
                    shift 2
                    ;;
                -r | --root)
                    ROOT="$(readlink -f "$2")"
                    shift 2
                    ;;
                -w | --readwrite)
                    RW=1
                    shift
                    ;;
                -c | --cmdline)
                    CMDLINE="$2"
                    shift 2
                    ;;
                --qemu)
                    QEMU="$2"
                    shift 2
                    ;;
                --net)
                    NET=1
                    shift
                    ;;
                -1 | --pid1)
                    PID1=1
                    shift
                    ;;
                --force)
                    DANGEROUS=1
                    shift
                    ;;
                -- )
                    shift
                    break
                    ;;
                * )
                    log_error_msg "Unknown argument \`$1'"
                    usage
                    exit 1
                    ;;
            esac
        done
        [ -n "$DANGEROUS" ] || [ -z "$RW" ] || [ -n "$ROOT" ] || \
            log_error_msg "Use of \`--readwrite' without \`--root' is too dangerous"
        [ -n "$DANGEROUS" ] || [ $(id -u) != 0 ] || \
            log_error_msg "You should not run this as root"

        KERNEL="${KERNEL:-/boot/vmlinuz-$(uname -r)}"
        ROOT="${ROOT:-/}"
        PATH="$PATH":/usr/local/sbin:/usr/sbin:/sbin

        check_kernel
        check_dependencies
        setup_tmp
        setup_initrd
        start_vm "$@"
        ret=255
        [ ! -f $TMP/config/ret ] || ret="$(cat $TMP/config/ret)"
        rm -rf $TMP || true
        exit $ret
        ;;
esac

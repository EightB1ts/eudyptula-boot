#!/bin/sh

set -e

ESC="$(printf '\033')"
if [ -t 1 ]; then
    NORMAL="${ESC}[0m"
    RED="${ESC}[31;1m"
    GREEN="${ESC}[32;1m"
    YELLOW="${ESC}[33;1m"
    BLUE="${ESC}[34;1m"
    BEGINNING="$(printf '\015\033')[K"
else
    BEGINNING="\n"
fi

log_begin_msg () {
    printf "${BEGINNING}"
    printf "${BLUE}[…]${NORMAL} $1${BLUE}...${NORMAL} "
}
log_ok_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$GREEN[✔]$NORMAL $1."
}
log_warn_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$YELLOW[⚡]$NORMAL $1!"
}
log_error_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$RED[✘]$NORMAL $1!"
    exit 1
}
log_info_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$BLUE[∗]$NORMAL $1."
}

usage() {
    >&2 cat <<EOF
Usage: $PROGNAME [ options ]
Boot a Linux kernel using the root filesystem of the host as a base.

Options:

 -k, --kernel=BZIMAGE  Specify the kernel to boot. By default, boot on the
                       running kernel.
 -r, --root=DIR        Specify the directory to use as the root file system.
 -c, --cmdline=ARGS    Additional parameters for the kernel.
 -e, --exec=CMD        Execute a command instead of spawning a shell.
 --qemu=OPTIONS        Additional options for QEMU.
 --net                 Enable network access through the host.

EOF
}

check_kernel() {
    log_begin_msg "Checking kernel version"
    [ -f "$KERNEL" ] || log_error_msg "Unable to find kernel $KERNEL"
    VERSION=$(file "$KERNEL" | sed -n 's/.*: Linux kernel x86 boot executable bzImage, version \([^ ]*\) .*/\1/p')
    [ -n "$VERSION" ] || log_error_msg "Unable to determine version for $KERNEL"
    log_ok_msg "Found kernel $VERSION"

    log_begin_msg "Check kernel configuration"
    CONFIG="$(dirname $KERNEL)/config-$VERSION"
    [ -f "$CONFIG" ] || log_error_msg "Unable to find configuration file $CONFIG"
    cat <<EOF | while read el; do
9P_FS=[ym]
NET_9P=[ym]
NET_9P_VIRTIO=[ym]
VIRTIO=[ym]
VIRTIO_PCI=[ym]
SERIAL_8250=y
SERIAL_8250_CONSOLE=y
TMPFS=y
SYSFS=y
PROC_FS=y
BLK_DEV_INITRD=y
RD_GZIP=y
EOF
        grep -qx "CONFIG_$el" $CONFIG || log_error_msg "Kernel not configured with CONFIG_$el"
    done
    if grep -qc "CONFIG_AUFS_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. AUFS present"
        aufs=yes
    else
        log_warn_msg "Kernel configuration checked. AUFS *not* present"
        aufs=no
    fi

    log_begin_msg "Search for modules"
    for dir in "$(dirname $KERNEL)/lib/modules/$VERSION" "/lib/modules/$VERSION"; do
        [ -d $dir ] || continue
        MODULES="$dir"
        break
    done
    if [ -z "$MODULES" ]; then
        log_warn_msg "Unable to find module directory"
    else
        log_ok_msg "Modules are in $MODULES"
    fi
}

check_dependencies() {
    log_begin_msg "Checking if dependencies are present"
    which busybox 2> /dev/null > /dev/null || log_error_msg "Busybox is not installed"
    which qemu-system-x86_64 2> /dev/null > /dev/null || log_error_msg "qemu-system is not installed"
    log_ok_msg "All dependencies are met"
}

setup_tmp () {
    TMP=$(mktemp -d)
    trap "rm -rf $TMP" EXIT
    log_info_msg "TMP is $TMP"
}

setup_initrd () {
    log_begin_msg "Build initrd"
    DESTDIR=$TMP/initrd
    mkdir -p $DESTDIR

    # Copy busybox and eventually insmod
    bins="busybox"
    busybox --list | grep -qFx insmod || bins="$bins insmod"
    for bin in $bins; do
        install -D "$(which $bin)" ${DESTDIR}/bin/$bin
        for x in $(ldd "$(which $bin)" 2> /dev/null | sed -e '
               /\//!d;
               /linux-gate/d;
               /=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
               s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/' 2>/dev/null); do
            [ -f "${DESTDIR}/$x" ] || install -D "$x" "${DESTDIR}/$x"
        done
    done

    # Configure busybox
    for applet in $(${DESTDIR}/bin/busybox --list); do
        ln -s busybox ${DESTDIR}/bin/${applet}
    done

    # Add modules
    [ -z "$MODULES" ] || {
        modules="9pnet_virtio 9p virtio_pci"
        [ x"$aufs" != x"yes" ] || modules="$modules aufs"
        for mod in $modules; do
            modprobe --all --set-version="${VERSION}" -d ${MODULES}/../../.. \
                --ignore-install --quiet --show-depends $mod > /dev/null || {
                log_warn_msg "Unable to find module $mod"
                log_begin_msg "Continue building initrd"
            }
            modprobe --all --set-version="${VERSION}" -d ${MODULES}/../../.. \
                --ignore-install --quiet --show-depends $mod |
            while read prefix kmod options ; do
                [ "${prefix}" = "insmod" ] || continue
                grep -qFw "$kmod" ${DESTDIR}/modules 2> /dev/null || {
                    install -D "$kmod" "${DESTDIR}/${kmod}"
                    echo $prefix $kmod $options >> ${DESTDIR}/modules
                }
            done
        done
    }

    # Copy this program
    cp "$PROGNAME" ${DESTDIR}/init

    # Create /tmp
    mkdir ${DESTDIR}/tmp

    # Build initrd
    cd "${DESTDIR}" && find . | cpio --quiet -R 0:0 -o -H newc | gzip > $TMP/initrd.gz

    log_ok_msg "initrd built in $TMP/initrd.gz"
}

start_vm () {
    name=$(echo eudyptula-${VERSION} | tr '.' '-')
    log_info_msg "Start VM $name"
    # /root is mounted with version 9p2000.u to allow access to /dev,
    # /sys and to mount new partitions over them. This is not the case
    # for 9p2000.L.
    append="uts=$name console=ttyS0 panic=1 TERM=$TERM aufs=$aufs quiet $CMDLINE"
    qemu="$QEMU"
    [ x"$NET" != x"1" ] || {
        mac=50:54:00:00:00:42
        qemu="$qemu -net nic,model=virtio,macaddr=$mac,vlan=1"
        qemu="$qemu -net user,vlan=1,name=internet"
    }
    [ -z "$EXEC" ] || {
        mkdir "$TMP/vm-exec"
        echo "$EXEC" > "$TMP/vm-exec/auto"
        qemu="$qemu -fsdev local,security_model=passthrough,id=fsdev-exec,path=$TMP/vm-exec,readonly"
        qemu="$qemu -device virtio-9p-pci,id=fs-exec,fsdev=fsdev-exec,mount_tag=execshare"
    }
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
        exec qemu-system-x86_64 \
        -enable-kvm \
        -nodefconfig -nodefaults \
        -display none \
        \
        -chardev stdio,id=charserial0,signal=off \
        -device isa-serial,chardev=charserial0,id=serial0 \
        -chardev socket,id=charserial1,path=$TMP/vm-$name-serial.pipe,server,nowait \
        -device isa-serial,chardev=charserial1,id=serial1 \
        \
        -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server,nowait \
        -mon chardev=con0,mode=readline,default \
        \
        -fsdev local,security_model=passthrough,id=fsdev-root,path=${ROOT} \
        -device virtio-9p-pci,id=fs-root,fsdev=fsdev-root,mount_tag=rootshare \
        -fsdev local,security_model=none,id=fsdev-home,path=${HOME} \
        -device virtio-9p-pci,id=fs-home,fsdev=fsdev-home,mount_tag=homeshare \
        -fsdev local,security_model=none,id=fsdev-modules,path=${MODULES}/..,readonly \
        -device virtio-9p-pci,id=fs-modules,fsdev=fsdev-modules,mount_tag=moduleshare \
        \
        -gdb unix:$TMP/vm-$name-gdb.pipe,server,nowait \
        -no-reboot \
        -kernel $KERNEL \
        -initrd $TMP/initrd.gz \
        -append "$append" \
        \
        $qemu
EOF
    log_info_msg "GDB server listening on $TMP/vm-$name-gdb.pipe"
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    log_info_msg "ttyS1 listening on      $TMP/vm-$name-serial.pipe"
    chmod +x "$TMP/vm-$name.exec"
    "$TMP/vm-$name.exec"
    log_info_msg "VM has terminated with status $?"
}

# FSM
export STATE=${STATE:-BEGIN}
case $$,$STATE in
    1,BEGIN)
        # In initrd
        log_info_msg "initrd started"
        hostname ${uts}
        export PATH=/usr/local/bin:/usr/bin:/bin:/sbin:/usr/local/sbin:/usr/sbin
        export HOME=/root

        [ ! -f /modules ] || {
            log_info_msg "Loading modules"
            . /modules
        }

        log_begin_msg "Setup root file system"
        mount -n -t tmpfs tmpfs /tmp -o rw
        mkdir /tmp/target
        mkdir /tmp/target/ro
        mkdir /tmp/target/overlay
        mount -n -t 9p    rootshare /tmp/target/ro      -o trans=virtio,version=9p2000.u,ro
        if [ x"$aufs" = x"yes" ]; then
            mkdir /tmp/target/rw
            mount -n -t tmpfs tmpfs     /tmp/target/rw      -o rw
            mount -n -t aufs  aufs      /tmp/target/overlay -o noxino,noatime,dirs=/tmp/target/rw:/tmp/target/ro=ro
        else
            mount -n --bind /tmp/target/ro /tmp/target/overlay
        fi
        mount -n -t proc  proc /tmp/target/overlay/proc
        mount -n -t sysfs sys  /tmp/target/overlay/sys
        log_ok_msg "Root file system setup"

        log_begin_msg "Clean /tmp and /run"
        for fs in /run /var/run /var/tmp /var/log /tmp; do
            if [ -d /tmp/target/overlay$fs ] && [ ! -h /tmp/target/overlay$fs ]; then
                mount -t tmpfs tmpfs /tmp/target/overlay$fs -o rw,nosuid,nodev
            fi
        done
        log_ok_msg "/tmp, /run and others are clean"


        log_begin_msg "Mount /root"
        mount -t 9p homeshare /tmp/target/overlay/root -o trans=virtio,version=9p2000.L,access=0,rw || \
            log_error_msg "Unable to mount /root"
        log_ok_msg "/root mounted"
        log_begin_msg "Mount /lib/modules"
        mount -t 9p moduleshare /tmp/target/overlay/lib/modules -o trans=virtio,version=9p2000.L,access=0,ro || \
            log_error_msg "Unable to mount /lib/modules"
        log_ok_msg "/root and /lib/modules mounted"

        log_info_msg "Change root"
        export STATE=CHROOTED
        cp /init /tmp/target/overlay/tmp
        exec chroot /tmp/target/overlay /tmp/init
        ;;

    1,CHROOTED)
        log_begin_msg "Starting udev"
        udev_log=err
        mount -n -o size=10M,mode=0755 -t devtmpfs devtmpfs /dev
        udevadm info --cleanup-db
        udevd --daemon
        udevadm trigger --action=add
        udevadm settle
        log_ok_msg "udev started"

        sysctl -w kernel.panic_on_oops=1

        log_begin_msg "Configure network"
        ip link set up dev lo
        for iface in /sys/class/net/*; do
            if [ x"$(cat "$iface/address")" = x"50:54:00:00:00:42" ]; then
                # We don't use DHCP as the root filesystem may be read-only
                ip link set up dev "${iface##*/}"
                ip addr add 10.0.2.14/24 dev "${iface##*/}"
                ip route add default via 10.0.2.2
                echo "nameserver 10.0.2.3" > /tmp/resolv.conf
                mount --bind /tmp/resolv.conf /etc/resolv.conf
                break
            fi
            iface=
        done
        log_ok_msg "Network configured${iface:+ (${iface##*/})}"

        # Do we have an exec share?
        execshare=$(mktemp -d)
        if mount -t 9p execshare $execshare \
            -o trans=virtio,version=9p2000.L,access=0,ro 2> /dev/null; then
            log_info_msg "Executing requested script"
            sh "$execshare/auto"
            echo b > /proc/sysrq-trigger
        fi
        
        log_info_msg "Setup terminal"
        export STATE=GETTY
        exec setsid /sbin/getty -L ttyS0 -a root -l /tmp/init -i 115200 $TERM
        ;;

    1,GETTY)
        log_begin_msg "Setup terminal size"
        # We are guaranteed to be in a tmux session, so we will get an
        # answer to the escape code we send. Otherwise, we may just
        # block!
        stty -echo
        stty raw
        printf '[18t'
        width=
        height=
        p=0
        while true; do
            char="$(timeout --foreground 1s dd bs=1 count=1 status=none || true)"
            case "$p,$char" in
                "0,;")
                    # End of CSI
                    p=1
                    ;;
                "1,;")
                    # End of height
                    stty rows $height
                    p=2
                    ;;
                "1,"*)
                    height="$height$char"
                    ;;
                "2,t"|"2,")
                    # End of width
                    stty columns $width
                    p=3
                    ;;
                "2,"*)
                    width="$width$char"
                    ;;
            esac
            [ x"$p" != x"3" ] || break
        done
        stty -raw
        stty echo
        log_ok_msg "Terminal size is $(tput cols)x$(tput lines)"

        log_begin_msg "Setup additional commands"
        mkdir /tmp/tools
        export PATH=$PATH:/tmp/tools
        cat <<EOF > /tmp/tools/reboot
#!/bin/sh
echo b > /proc/sysrq-trigger
EOF
        cat <<EOF > /tmp/tools/halt
#!/bin/sh
echo b > /proc/sysrq-trigger
EOF
        log_ok_msg "System can be halted with halt or reboot"

        log_info_msg "Spawning a shell"
        cd  $HOME
        export SSH_TTY=$(tty)
        if [ -f $HOME/.zshrc ]; then
            /bin/zsh -i
        else
            /bin/bash -i
        fi
        ;;

    *,BEGIN)
        # Initial state
        [ $(id -u) != 0 ] || log_error_msg "You should not run this as root"

        PROGNAME="$(readlink -f "$0")"
        ARGS="$(getopt -n eudyptula-boot \
            -o hk:r:c:e: \
            --longoptions help,kernel:,root:,cmdline:,qemu:,net,exec: \
            -- "$@")" || \
            log_error_msg "Invalid option, use --help for more information"
        eval set -- "$ARGS"
        while true; do
            case "$1" in
                -h | --help)
                    usage
                    exit 0
                    ;;
                -k | --kernel)
                    KERNEL="$(readlink -f "$2")"
                    shift 2
                    ;;
                -r | --root)
                    ROOT="$(readlink -f "$2")"
                    shift 2
                    ;;
                -c | --cmdline)
                    CMDLINE="$2"
                    shift 2
                    ;;
                --qemu)
                    QEMU="$2"
                    shift 2
                    ;;
                --net)
                    NET=1
                    shift
                    ;;
                -e | --exec)
                    EXEC="$2"
                    shift 2
                    ;;
                -- )
                    shift
                    break
                    ;;
                * )
                    log_error_msg "Unknown argument \`$1'"
                    usage
                    exit 1
                    ;;
            esac
        done
        [ $# -eq 0 ] || log_error_msg "Not accepting any additional argument"

        KERNEL="${KERNEL:-/boot/vmlinuz-$(uname -r)}"
        ROOT="${ROOT:-/}"

        check_kernel
        check_dependencies
        setup_tmp
        setup_initrd
        start_vm
        rm -rf $TMP || true
        ;;
esac
